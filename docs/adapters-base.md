---
type: Documentation
domain: knowledge
last_modified: 2026-02-02
generated: true
source: packages/knowledge/adapters/base.py
generated_at: 2026-02-02T22:24:17.214071
hash: 396af1f6b6335274e9b4fa47355eb740acb1cd8996e026329ad9cc0b80086af8
---

## Knowledge Adapter Base Class Documentation

This document describes the base class for adapters used in the documentation generation process. These adapters are responsible for handling different programming languages or file types. The core purpose is to provide a consistent interface for parsing, prompting, and processing source code to create documentation.

**Module Responsibilities:**

The `knowledge.adapters.base` module defines an abstract base class, `BaseAdapter`, that all language-specific adapters must inherit from. This ensures that each adapter implements a standardized set of methods for interacting with source code and a language model.

**Key Classes:**

*   **`BaseAdapter`**: This is an abstract base class (ABC) defining the interface for all documentation adapters. It cannot be instantiated directly. It enforces that any concrete adapter provides implementations for the `can_handle`, `parse`, `get_prompt`, `validate_content`, and `post_process` methods.

**Important Functions:**

*   **`can_handle(file_path: Path) -> bool`**: This method determines if a specific adapter is capable of processing a given file. It takes the file path as input and returns `True` if the adapter supports the file type, and `False` otherwise. You should implement this to check file extensions or content types.

*   **`parse(file_path: Path, content: str) -> List[str]`**: This method takes the file path and the raw content of the file as input. It is responsible for breaking down the content into smaller, manageable chunks suitable for processing by a language model. The method returns a list of strings, where each string represents a single chunk.

*   **`get_prompt(file_path: Path, parsed_content: str) -> str`**: This method generates the prompt that will be sent to the language model. It takes the file path and a single chunk of parsed content as input. The prompt should be crafted to instruct the language model to generate documentation for the given content. It returns the prompt string.

*   **`validate_content(content: str) -> List[str]`**: This method validates the input code content for potential issues like syntax errors or style violations. It accepts the code content as a string and returns a list of error messages. If the content is valid, it returns an empty list.

*   **`post_process(file_path: Path, outputs: List[str]) -> str`**: This method combines the outputs generated by the language model for each chunk of code. It takes the file path and a list of output strings as input. The default implementation simply joins the outputs with double newlines (`\n\n`), but you can override this method to implement more sophisticated combination logic.

**Type Hints:**

The code makes extensive use of type hints (e.g., `file_path: Path`, `content: str`, `-> bool`). These hints improve code readability and allow for static analysis, helping to catch potential errors during development. The `Path` type from the `pathlib` module is used to represent file paths in a platform-independent manner. `List[str]` indicates a list containing strings.

**Design Decisions and Patterns:**

*   **Abstract Base Class:** The use of an abstract base class enforces a consistent interface for all adapters, promoting code maintainability and extensibility.
*   **Separation of Concerns:** Each adapter is responsible for handling a specific language or file type, keeping the code modular and organized.
*   **Chunking:** The `parse` method breaks down large files into smaller chunks to avoid exceeding the language model's input length limitations.
*   **Prompt Engineering:** The `get_prompt` method allows for customization of the prompt sent to the language model, enabling fine-tuning of the documentation generation process.